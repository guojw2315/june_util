{"version":3,"sources":["../src/search.js"],"names":["bfs","treeList","callback","childrenKey","key","queue","list","level","parentKeyMap","length","temp","i","item","Object","create","_level","keys","keyItem","keyItemList","split","parentKey","isBreak","splice","pop","dfs","console","warn","push","slice"],"mappings":"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","sourcesContent":["\r\n/**\r\n * @description 广度优先遍历树形数组 - 循环实现\r\n */\r\nexport function bfs(treeList, callback, { childrenKey = 'children', key = 'key' } = {}) {\r\n    let queue = [[]];\r\n    let list = treeList;\r\n    let level = 1;\r\n    let parentKeyMap = {};\r\n    while (queue.length) {\r\n        let temp = [];\r\n        for (let i = 0; i < list.length; i++) {\r\n            let item = Object.create(list[i]);\r\n\r\n            item._level = level;\r\n\r\n            for (let keyItem of Object.keys(parentKeyMap)) {\r\n                let keyItemList = keyItem.split('_');\r\n                if (level - 1 == keyItemList[0] && i >= +keyItemList[1] && i <= +keyItemList[2]) {\r\n                    item.parentKey = parentKeyMap[keyItem];\r\n                }\r\n            }\r\n\r\n            if (item[childrenKey]) {\r\n                parentKeyMap[`${level}_${temp.length}_${temp.length + item[childrenKey].length - 1}`] = item[key];\r\n                temp = [...temp, ...item[childrenKey]];\r\n            }\r\n\r\n            if (callback) {\r\n                let isBreak = callback({ ...item, ...list[i] }, list[i]);\r\n                if (isBreak) return;\r\n            }\r\n\r\n            if (i === list.length - 1) {\r\n                level++;\r\n                queue.splice(1, 0, temp);\r\n            }\r\n        }\r\n\r\n        list = queue.pop();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @description 深度优先遍历树形数组 - 循环实现\r\n * @param {*} treeList [{key, name}, ...]\r\n * @param {*} callback ({key:T, name:dynamic, level:int, parentKey:T})\r\n */\r\nexport function dfs(treeList, callback, { childrenKey = 'children', key = 'key' } = {}) {\r\n    if (!treeList) return console.warn('target must be array')\r\n    let queue = [[]];\r\n    let list = treeList;\r\n    let parentKeyMap = {};\r\n    while (queue.length) {\r\n        for (let i = 0; i < list.length; i++) {\r\n            let item = Object.create(list[i]);\r\n            item._level = queue.length;\r\n            item.level = queue.length;\r\n            if (parentKeyMap[item._level - 1])\r\n                item.parentKey = parentKeyMap[item._level - 1];\r\n            if (callback) {\r\n                let isBreak = callback({ ...item, ...list[i] }, list[i]);\r\n\r\n                if (isBreak) return;\r\n            }\r\n\r\n\r\n            if (item[childrenKey]) {\r\n                parentKeyMap[item._level] = item[key];\r\n                queue.push(list.slice(i + 1));\r\n                queue.push(item[childrenKey]);\r\n\r\n                break;\r\n            }\r\n\r\n        }\r\n        list = queue.pop();\r\n    }\r\n}\r\n"],"file":"search.js"}